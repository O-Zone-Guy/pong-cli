#+title: Pong(CLI) Requirement and Specification Document
#+author: Omar Alkersh
#+options: toc:nil num:nil
#+latex_header: \usepackage[a4paper, margin=1in]{geometry} \usepackage[utf8]{inputenc}

This project is an implementation of the [[https://en.wikipedia.org/wiki/Pong][Pong]] game in C++ using the PDCurses library. The purpose of this project is to practice C++, project planning, and writing SRS(Software Requirement and Specification) document.

* Requirements
  The software produced must be platform agnostic, between *nix and Windows machines. This game will run as a command line application. It shall start with a menu containing the following options: VS Computer, VS Player, and Exit. VS Computer will start the game with one of the pong pedals controlled by a computer. VS Player will start the game with both pedals controlled by user input. Exit will terminate the program.

  The game will follow the general rules of pong as described in the link above with the following specifications:

  - The ball will launch in a random direction.
    - When the score is 0 - 0 the side to launch to is randomised
    - Else, the ball will go to the direction of the player that scored the previous goal.
  - The ball will deflect normally from the upper and lower bounds/walls.
  - The ball will deflect based on the angle to the centre of the colliding pedal.
    - The vector to the centre of the pedal from the centre of the ball will serve as the collision normal.

  Navigating the software will be entirely using the keyboard. The menu can be navigated using the arrow keys or using j/k to go up/down. ~return~ will serve to select.

  The game controls are as follows:

  |           | Player 1 (Main Player) | Player 2 |
  |-----------+------------------------+----------|
  | Move up   | ~k/up~                 | ~w~      |
  | Move down | ~j/down~               | ~s~      |
  | Pause     | ~esc~                  | ~esc~    |

* Vector2D Module

** Template Module
   Vector2D
** Syntax

*** Exported Types

    Vector2D = ?

*** Exported Access Program

    | Routine name | Input    | Out      | Exceptions         |
    |--------------+----------+----------+--------------------|
    | Vector2D     | ‚Ñï, ‚Ñï     | Vector2D |                    |
    | Vector2D     | ‚Ñù, ‚Ñù     | Vector2D |                    |
    | getX         |          | ‚Ñù        |                    |
    | getY         |          | ‚Ñù        |                    |
    | getMag       |          | ‚Ñù        |                    |
    | mulMag       | ‚Ñù        |          |                    |
    | setMag       | ‚Ñù        |          | =invalid_argument= |
    | addMag       | ‚Ñù        |          |                    |
    | addX         | ‚Ñù        |          |                    |
    | addY         | ‚Ñù        |          |                    |
    | rotate       | ‚Ñù        |          |                    |
    | angleBetween | Vector2D | ‚Ñù        | =invalid_argument= |
    | (==)         | Vector2D | ùîπ        |                    |
    | -()          |          | Vector2D |                    |
    | (+)          | Vector2D | Vector2D |                    |
    | (*)          | Vector2D | ‚Ñù        | =invalid_argument= |

*** Semantics

**** State Variables

     rad: ‚Ñù

     mag: ‚Ñù

**** State Invariant

     - mag ‚â• 0
     - -œÄ < rad ‚â§ œÄ

**** Assumptions

     Vector2D is called before any other function is called.
**** Access Routine Semantics

     ~new~ Vector2D(ùë•: ‚Ñï, ùë¶: ‚Ñï):
     - transition: $self.mag, self.rad := \sqrt{x^2 + y^2}, atan2(x, y)$
     - out: $out := self$
     - exception: None


     ~new~ Vector2D(rad: ‚Ñù, mag: ‚Ñù):
     - transition: $self.mag, self.rad := mag, rad$
     - out: $out := self$
     - exception: None


     getX():
     - out: $out := self.x$


     getY():
     - out: $out := self.y$

     getMag():
     - out: $out := \sqrt{x^2 + x^2}$
     - exception: none

    mulMag(ùëö):
    - transition: $x, y := x\cdot m, y\cdot m$
    - exception: None


    setMag(ùëö):
    - transition: $ùë•, ùë¶ := x\cdot \frac{m}{getMag()}$, $y\cdot \frac{m}{getMag()}$
    - exception: $exc := ùëö < 0 ‚áí$ =invalid_argument=


    addMag(ùëö):
    - transition: $self.mag := mag$
    - exception: None


    addX(ùë•_ùëë):
    - transition: $mag, rad := sqrt{mag^2 + x_d^2 + 2getX()\cdot x_d}, atan2(getX() + x_d, getY())$
    - exception: None


    addY(ùë¶_ùëë):
    - transition: $mag, rad := sqrt{mag^2 + y_d^2 + 2getY()\cdot y_d}, atan2(getX(), getY() + y_d)$
    - exception: None

    rotate(ùëü):
    - transition: $ùë•, ùë¶ := ùë•¬∑cos(ùëü) - ùë¶¬∑sin(ùëü), ùë•¬∑sin(ùëü) + ùë¶¬∑cos(ùëü)$
    - exception: None


    angleBetween(ùë£):
    - out: $out := cos^{-1}(self.prod(v))$
    - exception: $exc := v.getMag() ‚â§ 0 ‚áí$ =invalid_argument=


    this + ùë£:
    - out: $out := new Vector2D(self.x + v.getX(), self.y + v.getY())$
    - exception: None


    this * ùë£:
    - out: $out := self.x\cdot v.getX() + self.y\cdot v.getY()$
    - exception: None


\newpage
* Point2D
** Template Module
   Point2D
** Uses

** Syntax
*** Exported Types
    Point2D
*** Exported Access Program
    | Routine name | Input   | Output  | Exceptions |
    |--------------+---------+---------+------------|
    | Point2D      | ‚Ñï, ‚Ñï    | Point2D |            |
    | getX         |         | ‚Ñï       |            |
    | getY         |         | ‚Ñï       |            |
    | move         | ‚Ñï, ‚Ñï    |         |            |
    | set          | ‚Ñï, ‚Ñï    |         |            |
    | compareTo    | Point2D | ‚Ñï       |            |

*** Semantics

**** State Variables

     ùë•: ‚Ñï

     ùë¶: ‚Ñï

**** State Invariant

     None

**** Assumptions

     Point2D gets called before other method calls.

**** Access Routine Semantics

     ~new~ Point2D(ùë•, ùë¶):
     - transition: $self.y, self.y := x, y$
     - out: $out := self$
     - exception: None


     getX():
     - out: $out := ùë•$


     getY():
     - out: $out := ùë¶$


     move(ùë•, ùë¶):
     - transition: $self.x,  self.y := self.x + x, self.y + y$


     set(ùë•, ùë¶):
     - transition: $self.x, self.y := x, y$


     compareTo(ùëù):
     - out: $out :=$
       #+begin_export latex
       \begin{align*}
         (‚ü® self.getX(), self.getY() ‚ü© <_{lex}‚ü®ùëù.getX(), ùëù.getY() ‚ü©) &‚áí -1 |\\
         (‚ü® self.getX(), self.getY() ‚ü© >_{lex}‚ü®ùëù.getX(), ùëù.getY() ‚ü©) &‚áí 1 |\\
         True &‚áí 0
       \end{align*}
       #+end_export


\newpage

* Paddle
** Template Module
   Paddle
** Uses
   Point2D, PDCurses
** Syntax
*** Exported Constants
    
    SPEED: ‚Ñï = ?
    
*** Exported Types
    
    Paddle : ?
    
    Direction = {Up, Down, None}

*** Exported Access Program

    | Routine name | Input              | Output  | Exceptions     |
    |--------------+--------------------+---------+----------------|
    | Paddle[fn:1] | Point2D, WINDOW, ‚Ñï | Paddle  | =out_of_range= |
    | move         | Direction          |         |                |
    | move         | ‚Ñù                  |         |                |
    | moveTo       | Point2D            |         | =out_of_range= |
    | getPos       |                    | Point2D |                |

*** Semantics
**** State Variables
     
     pos: Point2D

     window: WINDOW
     
     direction: Direction
     
     length: ‚Ñï

**** State Invariant
     
     *Need a more formal spec.*
     
     The paddle never goes out of the window. For a more formal spec I need the size of the window and the length of the paddle. Probably will figure it mid development.

**** Assumptions
**** Access Routine Semantics
     
     ~new~ Paddle(p, w, l):
     - transition: $pos, window, length := p, w, l$
     - Out: $out := self$
     - Exception: $exc := $ =out_of_range=
       

     move(d):
     - transition: $direction := d$
     - Exception: None
    

     move(timeD):
     - transition:
       #+begin_export latex
       \begin{align*}
         direction = Up   &‚áí & pos.move(0, timeD \cdot -SPEED) &|\\
         direction = Down &‚áí & pos.move(0, timeD \cdot SPEED)  &|\\
         direction = None &‚áí & None                        &|\\
       \end{align*}
       #+end_export
     - Note: Need to check for boundaries before moving.
     - Exception: None
     
       
     moveTo(p):
     - transition: $pos := p$
     - Exception: $exc := $ Check boundaries.
     

     getPos():
     - Out: $out := pos$
     - Exception: None

* Ball
** Module
   
   Ball

** Uses
   
   Vector2D, Point2D

** Syntax

*** Exported Constants
    
*** Exported Types
    
    Ball

*** Exported Access Program

    | Routine name | Input                           | Output | Exceptions     |
    |--------------+---------------------------------+--------+----------------|
    | Ball         | Point2D, Vector2D, ‚Ñï, ‚Ñï, WINDOW | Ball   | =out_of_range= |
    | move         | ‚Ñù                               |        |                |
    | isAtGoal     |                                 | ùîπ      |                |
    | bounce       | Vector2D                        |        |                |
    | reset        | Point2D, Velocity               |        | =out_of_range= |

*** Semantics
**** State Variables
     
     pos: Point2D
     
     velocity: Vector2D

     leftBound: ‚Ñï

     rightBound: ‚Ñï
     
     window: WINDOW

**** State Invariant
     
     *Need a more formal spec.*
     
     The paddle never goes out of the window. For a more formal spec I need the size of the window and the length of the paddle. Probably will figure it mid development.

**** Assumptions

**** Access Routine Semantics
     
     ~new~ Ball(p, v, lb, rb, win):
     - transition: $pos, velocity, leftBound, rightBound, window := p, v, lb, rb, win$
     - Out: $out := self$
     - Exception: $exc :=$ =out_of_range= if the spawn position is out of the window bounds.
     

     move(timeD)
     - transition: $pos.move(velocity.getX() \cdot timeD, velocity.getX() \cdot timeD)$, will also call ~bounce~ when necessary.
     - Exception: None
     
       
     isAtGoal():
     - Out: $out := pos.getX() < leftBound ‚à® pos.getX() > rightBound$
     - Exception: None
     

     bounce(n):
     - transition: $velocity = velocity - 2 (velocity \cdot n) n$
     - Exception: None
     

     reset(p, v):
     - transition: $pos, velocity := p, v$
     - Exception: $exc :=$ =out_of_range= if the spawn position is out of the window bounds.

* Footnotes

[fn:1] Maybe add another parameter to define the side. Or just let the controller put it in the correct side.

* settings                                                         :noexport:

# Local Variables:
# org-latex-inputenc-alist: (("utf8" . "utf8x"))
# eval: (setq org-latex-default-packages-alist (cons '("mathletters" "ucs" nil) org-latex-default-packages-alist))
# End:
