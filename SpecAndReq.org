#+title: Pong(CLI) Requirement and Specification Document
#+author: Omar Alkersh
#+options: toc:nil num:nil
#+latex_header: \usepackage[a4paper, margin=1in]{geometry} \usepackage[utf8]{inputenc}

This project is an implementation of the [[https://en.wikipedia.org/wiki/Pong][Pong]] game in C++ using the PDCurses library. The purpose of this project is to practice C++, project planning, and writing SRS(Software Requirement and Specification) document.

* Requirements
  The software produced must be platform agnostic, between *nix and Windows machines. This game will run as a command line application. It shall start with a menu containing the following options: VS Computer, VS Player, and Exit. VS Computer will start the game with one of the pong pedals controlled by a computer. VS Player will start the game with both pedals controlled by user input. Exit will terminate the program.

  The game will follow the general rules of pong as described in the link above with the following specifications:

  - The ball will launch in a random direction.
    - When the score is 0 - 0 the side to launch to is randomised
    - Else, the ball will go to the direction of the player that scored the previous goal.
  - The ball will deflect normally from the upper and lower bounds/walls.
  - The ball will deflect based on the angle to the centre of the colliding pedal.
    - The vector to the centre of the pedal from the centre of the ball will serve as the collision normal.

  Navigating the software will be entirely using the keyboard. The menu can be navigated using the arrow keys or using j/k to go up/down. ~return~ will serve to select.

  The game controls are as follows:

  |           | Player 1 (Main Player) | Player 2 |
  |-----------+------------------------+----------|
  | Move up   | ~k/up~                 | ~w~      |
  | Move down | ~j/down~               | ~s~      |
  | Pause     | ~esc~                  | ~esc~    |

* Vector2D Module

** Template Module
   Vector2D
** Syntax

*** Exported Types

    Vector2D = ?

*** Exported Access Program

    | Routine name | Input    | Out      | Exceptions         |
    |--------------+----------+----------+--------------------|
    | Vector2D     | ‚Ñù, ‚Ñù     | Vector2D |                    |
    | getX         |          | ‚Ñù       |                    |
    | getY         |          | ‚Ñù       |                    |
    | getMag       |          | ‚Ñù        |                    |
    | angleBetween | Vector2D | ‚Ñù        | =invalid_argument= |
    | mulMag       | ‚Ñù        |          |                    |
    | setMag       | ‚Ñù        |          | =invalid_argument= |
    | rotate       | ‚Ñù        |          |                    |
    | add          | Vector2D | Vector2D |                    |
    | prod         | Vector2D | ‚Ñù        | =invalid_argument= |

*** Semantics

**** State Variables

     ùë•: ‚Ñù

     ùë¶: ‚Ñù

**** State Invariant

     - =getMag()= ‚â• 0
     - -œÄ < =angleBetween(ùë•)= ‚â§ œÄ

**** Assumptions

     Vector2D is called before any other function is called.
**** Access Routine Semantics

     ~new~ Vector2D(ùë•, ùë¶):
     - transition: $self.x, self.y := x, y
     - out: $out := self$
     - exception: none


     getX():
     - out: $out := self.x$


     getY():
     - out: $out := self.y$

     getMag():
     - out: $out := \sqrt{x^2 + x^2}$
     - exception: none


    angleBetween(ùë£):
    - out: $out := cos^{-1}(self.prod(v))$
    - exception: $exc := v.getMag() ‚â§ 0 ‚áí$ =invalid_argument=


    mulMag(ùëö):
    - transition: $x, y := x\cdot m, y\cdot m$
    - exception: None


    setMag(ùëö):
    - transition: $ùë•, ùë¶ := x\cdot \frac{m}{getMag()}$, $y\cdot \frac{m}{getMag()}$
    - exception: $exc := ùëö < 0 ‚áí$ =invalid_argument=


    rotate(ùëü):
    - transition: $ùë•, ùë¶ := ùë•¬∑cos(ùëü) - ùë¶¬∑sin(ùëü), ùë•¬∑sin(ùëü) + ùë¶¬∑cos(ùëü)$
    - exception: None


    add(ùë£):
    - out: $out := new Vector2D(self.x + v.getX(), self.y + v.getY())$
    - exception: None


    prod(ùë£):
    - out: $out := self.x\cdot v.getX() + self.y\cdot v.getY()$


\newpage
* Point2D
** Template Module
   Point2D
** Uses

** Syntax

*** Exported Types
    Point2D
*** Exported Access Program
    | Routine name | Input   | Output  | Exceptions |
    |--------------+---------+---------+------------|
    | Point2D      | ‚Ñï, ‚Ñï    | Point2D |            |
    | getX         |         | ‚Ñï       |            |
    | getY         |         | ‚Ñï       |            |
    | move         | ‚Ñï, ‚Ñï    |         |            |
    | set          | ‚Ñï, ‚Ñï    |         |            |
    | compareTo    | Point2D | ‚Ñï       |            |

*** Semantics

**** State Variables

     ùë•: ‚Ñï

     ùë¶: ‚Ñï

**** State Invariant

     None

**** Assumptions

     Point2D gets called before other method calls.

**** Access Routine Semantics

     ~new~ Point2D(ùë•, ùë¶):
     - transition: $self.y, self.y := x, y$
     - out: $out := self$
     - exception: None


     getX():
     - out: $out := ùë•$


     getY():
     - out: $out := ùë¶$


     move(ùë•, ùë¶):
     - transition: $self.x,  self.y := self.x + x, self.y + y$


     set(ùë•, ùë¶):
     - transition: $self.x, self.y := x, y$


     compareTo(ùëù):
     - out: $out :=$
       #+begin_export latex
       \begin{align*}
         (‚ü® self.getX(), self.getY() ‚ü© <_{lex }‚ü®ùëù.getX(), ùëù.getY() ‚ü©) &‚áí -1 |\\
         (‚ü® self.getX(), self.getY() ‚ü© >_{lex }‚ü®ùëù.getX(), ùëù.getY() ‚ü©) &‚áí 1 |\\
         True &‚áí 0
       \end{align*}
       #+end_export


\newpage
* settings                                                         :noexport:
# Local Variables:
# org-latex-inputenc-alist: (("utf8" . "utf8x"))
# eval: (setq org-latex-default-packages-alist (cons '("mathletters" "ucs" nil) org-latex-default-packages-alist))
# End:
